//////////////////////////////////////////////////////////////////////////////
//
// Projector.h:  Object to read files generated by modified CERR (Matlab)
// code, (in visualStruct3D.m), place the data thereby acquired into a
// vtkPolyData object, color according to the agreed-upon convention, and
// display images.
//
//////////////////////////////////////////////////////////////////////////////

#ifndef PROJECTOR_H
#define PROJECTOR_H

#include <qstring.h>

#define STRAIGHTPIPE 0 // Skip decimation and smoothing if non-zero
#define DISPLAY_AXES 0

// To initialize variables for holding geometric extrema:
const double kMinInit = DBL_MAX;
const double kMaxInit = -DBL_MAX;

const int kMaxChars = 255;
const int kMaxFileTypeChars = 9;
const int kMaxStructureTypeChars = 8;

// The Carl Zhang/Vorakarn Chanyavanich convention for naming input files:
//     <inFileType>_<patient number>_<structure>.out
// where <inFileType> = [ "faces" | "vertices" ],
//       <patient number> is a 3-digit integer (possibly front-padded with 0's),
// and   <structure>  = [ "bladder" | "LtFem" | "PTV" | "rectum" | "RtFem" ].
//

// forward declarations:
class vtkPolyData;
class vtkDecimatePro;
class vtkSmoothPolyDataFilter;
class vtkPolyDataNormals;
class vtkPolyDataMapper;
class vtkActor;
class vtkRenderer;
class vtkRenderWindowInteractor;
class vtkRenderWindow; 
class vtkTextActor;
class QVTKWidget;

class Projector
{
public:
	enum eInFileType
	{
	  ekFaces = 0,
	  ekVertices
	};

	static const int kNumInFileTypes; // = ekVertices + 1;

	//const char inFileType[kNumInFileTypes][kMaxFileTypeChars] = {"faces", "vertices"};

	enum eStructureType
	{
	  ekBladder = 0,
	  ekLtFem = 1,
	  ekPTV = 2,
	  ekRectum = 3,
	  ekRtFem = 4,
	  kNumStructureTypes = 5, // = last structure type + 1: currently no body
	  ekBody = 5
	};

	//const int kNumStructureTypes = ekRtFem + 1;
	//static const int kNumStructureTypes; // = ekBody + 1;

	Projector();
	Projector(QString dataDir);
	~Projector() {};
	void setFlatShaded(bool value) { flatShaded = value; };
	void setNoFemoralHeads(bool value) { noFemoralHeads = value; };
	void setTransparency(int transp);

	void AddFollowingText(char *text, double x, double y, double z, double r,
                      double g, double b, vtkRenderer *ren);
	void AddOriginToRenWin(vtkRenderer *r);
	void AddOrigin(void);
	void WindowInit(vtkRenderWindow *renWin, QVTKWidget *qVTKWidget);
	void InitExtrema(void);
	void PrintStructureName(eStructureType structureNum);
	void ComputeAvgZ(void);
	void WriteExtremaToFile(ofstream &outf, int patientNum);
	static void ReportCameraPosition(vtkRenderer *renderer);
	void SetCameraPosition(vtkRenderer *renderer, double pos[3], double fp[3], double vUp[3]);
	void SetCameraPosition(double az);
	void UpdateExtrema(eStructureType structure, double v[3]);
	bool BuildStructure(int patientNum, eStructureType st);
	bool BuildStructuresForPatient(int patientNum);
	void InitAxes(void);
	void TextInit(void);
	void SetProjection(int patientNum, int queryAngle);

private:
	vtkPolyData *structure;
	vtkDecimatePro *deci;
	vtkSmoothPolyDataFilter *smoother;
	vtkPolyDataNormals *normals;
	vtkPolyDataMapper *mapper;
	vtkActor *actor;
	vtkRenderWindowInteractor *renderWindowInteractor;
	vtkRenderWindow *renWin; 
	vtkTextActor *textActor;

	bool flatShaded;
	bool noFemoralHeads;
	int transparency; // percentage

	QString inPathFormat;

public: // TEMP
	vtkRenderer *renderer;

private:
	// To hold vertex extrema values (x, y, and z) for each of the structures read
	// in/displayed:
/*	double maxVal[kNumStructureTypes][3];
	double minVal[kNumStructureTypes][3];

	// Hack: make space to keep max- and minVal from overwriting adjacent memory:
	double maxHack[kNumStructureTypes][3];
	double minHack[kNumStructureTypes][3];
*/
	// Normalize camera placement in z:
	double avgZ; 

	// Write images to disk:
	//vtkPNGWriter *pngWriter = NULL;
	//vtkWindowToImageFilter *windowToImageFilter = NULL;
};

#endif // #ifndef PROJECTOR_H