//////////////////////////////////////////////////////////////////////////////
//
// Projector.h:  Object to read files generated by modified CERR (Matlab)
// code, (in visualStruct3D.m), place the data thereby acquired into a
// vtkPolyData object, color according to the agreed-upon convention, and
// display images.
//
//////////////////////////////////////////////////////////////////////////////

#include "windows.h" 
#include <float.h>

#include <QtGui>
#include "qvtkwidget.h"

#include "vtkPolyDataMapper.h"
#include "vtkActor.h"
#include "vtkProperty.h"
#include "vtkCamera.h"
#include "vtkRenderer.h"
#include "vtkRenderWindowInteractor.h"
#include "vtkRenderWindow.h"
#include "vtkVectorText.h"
#include "vtkConeSource.h"
#include "vtkCubeSource.h"
#include "vtkCylinderSource.h"
#include "vtkFollower.h"
#include "vtkTextActor.h"
#include "vtkCommand.h"
#include "vtkWindowToImageFilter.h"
#include "vtkPNGWriter.h"
#include "vtkCellArray.h"
#include "vtkDecimatePro.h"
#include "vtkPolyDataNormals.h"
#include "vtkSmoothPolyDataFilter.h"
#include "vtkAxes.h"
#include "vtkWindowToImageFilter.h"
#include "vtkAssembly.h"

#include "Projector.h"

using namespace std;

// Window size and position:
static const int kRenWinX = 512;
static const int kRenWinY = 512;

// const member initializations:
const int Projector::kNumInFileTypes = ekVertices + 1;

static const char inFileType[Projector::kNumInFileTypes][kMaxFileTypeChars] = {"faces", "vertices"};

static const char structureType[Projector::kNumStructureTypes][kMaxFileTypeChars] = 
	{"bladder", "LtFem", "PTV", "rectum", "RtFem" /*, "body" */};


// 2011/05/02: values from current CompareDialog:
static const double structureColor[Projector::kNumStructureTypes][3] =
{
	1.0, 0.84, 0.0,			// bladder "golden yellow"
	0.33, 0.33, 0.4,		// left femoral head blue-gray
	0.9, 0.0, 0.0,			// PTV red     
	0.545, 0.271, 0.075,	// rectum "saddle brown"
	0.67, 0.67, 0.67		// right femoral head lite gray
//		0.961, 0.8, 0.69		// flesh F5CCB0 = 245, 204, 176 = 0.961, 0.8, 0.69
};

// To hold vertex extrema values (x, y, and z) for each of the structures read
// in/displayed:
double maxVal[Projector::kNumStructureTypes][3];
double minVal[Projector::kNumStructureTypes][3];

// Hack: make space to keep max- and minVal from overwriting adjacent memory:
double maxHack[Projector::kNumStructureTypes][3];
double minHack[Projector::kNumStructureTypes][3];

// The Carl Zhang/Vorakarn Chanyavanich convention for naming structure 
// geometry input files:
//
//     <inFileType>_<patient number>_<structure>.out
// where <inFileType> = [ "faces" | "vertices" ],
//       <patient number> is a 3-digit integer (possibly front-padded with 0's),
// and   <structure>  = [ "bladder" | "LtFem" | "PTV" | "rectum" | "RtFem" ].
//
//char inPathFormat[] = 
//"C:/Users/Steve/Documents/IMRT/Zhang-test/PMC069_body_included/%s_PMC%03d_%s.out"; // test case for body
//"C:/Users/Steve/Documents/IMRT/structures-2010-11-30/%03d/%s_%03d_%s.out";
//"C:/Duke_Cases_2011-06-13/structures/%03d/%s_%03d_%s.out";

// Axes:
/*vtkActor *oActor = NULL;
vtkActor *xConeActor = NULL;
vtkActor *yConeActor = NULL;
vtkActor *zConeActor = NULL;
vtkActor *xShaftActor = NULL;
vtkActor *yShaftActor = NULL;
vtkActor *zShaftActor = NULL;
*/

// Forward declaration:
//static void Projector::ReportCameraPosition(vtkRenderer *renderer);

class RendererCallback : public vtkCommand
{
public:
  static RendererCallback *New() { return new RendererCallback; }

  ///Execute////////////////////////////////////////////////////////////////////
  // 
  // Gets called whenever the user interactively manipulates the camera.  
  //
  //////////////////////////////////////////////////////////////////////////////
  virtual void Execute(vtkObject *caller, unsigned long, void *)
  {
    vtkRenderer *r = vtkRenderer::SafeDownCast(caller);
    //Projector::ReportCameraPosition(r);
  }
};

///ctor/////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////
Projector::Projector()
	:	structure(NULL),
		deci(NULL),
		smoother(NULL),
		normals(NULL),
		mapper(NULL),
		actor(NULL),
		renderWindowInteractor(NULL),
		renWin(NULL), 
		textActor(NULL),
		renderer(NULL),
		flatShaded(true),
		noFemoralHeads(false),
		avgZ(0.0)
{
}

///ctor/////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////
Projector::Projector(QString dataDir)
	:	structure(NULL),
		deci(NULL),
		smoother(NULL),
		normals(NULL),
		mapper(NULL),
		actor(NULL),
		renderWindowInteractor(NULL),
		renWin(NULL), 
		textActor(NULL),
		renderer(NULL),
		flatShaded(true),
		noFemoralHeads(false),
		avgZ(0.0)
{
	inPathFormat = dataDir + "/structures/%03d/%s_%03d_%s.out";
}

///AddFollowingText/////////////////////////////////////////////////////////////
// 
// Specify some text, where you want it to go in 3-space, a color, and a
// renderer, and it will always face the active camera associated with that
// renderer.
//
////////////////////////////////////////////////////////////////////////////////
vtkFollower *Projector::AddFollowingText(char *text, double x, double y, double z,
	double r, double g, double b, vtkRenderer *ren)
{
  vtkVectorText *xText = vtkVectorText::New();;
  vtkPolyDataMapper *xTextMapper = vtkPolyDataMapper::New();
  vtkFollower *xTextActor = vtkFollower::New();

  xText->SetText(text);
  xTextMapper->SetInputConnection(xText->GetOutputPort());
  xTextActor->SetMapper(xTextMapper);
  xTextActor->SetScale(2, 2, 2);
  xTextActor->AddPosition(x, y, z);
  xTextActor->GetProperty()->SetColor(r, g, b);
  xTextActor->SetCamera(ren->GetActiveCamera());
  ren->AddActor(xTextActor);

  return xTextActor;
}

void Projector::setTransparency(int transp)
{
	transparency = transp;
}


///AddOriginToRenWin////////////////////////////////////////////////////////////
//
// Put the three colored arrows and the white cube at (0, 0, 0) from which they
// emanate into the window whose renderer is pointed to by r.
//
// Assumes that all the various geometric objects and their associated mappers 
// and actors have been created and connected appropriately.
//
////////////////////////////////////////////////////////////////////////////////
vtkAssembly *Projector::AddOriginToRenWin(vtkRenderer *r)
{
/*  char x[] = "+x";
  char y[] = "+y";
  char z[] = "+z";

  r->AddActor(xConeActor);
  r->AddActor(yConeActor);
  r->AddActor(zConeActor);
  r->AddActor(xShaftActor);
  r->AddActor(yShaftActor);
  r->AddActor(zShaftActor);
  r->AddActor(oActor);

  AddFollowingText(x, 23, -1, 0, 1, 0, 0, r);
  AddFollowingText(y, -1, 23, 0, 0, 1, 0, r);
  AddFollowingText(z, 0, -1, 23, 0, 0, 1, r);
*/
  vtkAssembly *assembly = vtkAssembly::New();
  return assembly;
}

///AddOrigin////////////////////////////////////////////////////////////////////
//
// The standard three arrows -- red = x, green = y, blue = z -- emanating from a
// white cube.
//
////////////////////////////////////////////////////////////////////////////////
vtkAssembly *Projector::AddOrigin(vtkRenderer *renderer, double shaftLength /* = 20.0 */)
{
  vtkActor *oActor = NULL;
  vtkActor *xConeActor = NULL;
  vtkActor *yConeActor = NULL;
  vtkActor *zConeActor = NULL;
  vtkActor *xShaftActor = NULL;
  vtkActor *yShaftActor = NULL;
  vtkActor *zShaftActor = NULL;

  vtkConeSource *xCone = vtkConeSource::New();
  vtkPolyDataMapper *xConeMapper = vtkPolyDataMapper::New();
  xConeActor = vtkActor::New();
  xCone->SetResolution(40);
  xCone->SetHeight(shaftLength / 10.0);
  xCone->SetRadius(shaftLength * 0.0375);
  xCone->SetDirection(1, 0, 0);
  xConeMapper->SetInputConnection(xCone->GetOutputPort());
  xConeActor->SetPosition(shaftLength, 0, 0);
  xConeMapper->ScalarVisibilityOff();
  xConeActor->SetMapper(xConeMapper);
  xConeActor->GetProperty()->SetColor(1, 0, 0);
  
  vtkCylinderSource *xShaft = vtkCylinderSource::New();
  vtkPolyDataMapper *xShaftMapper = vtkPolyDataMapper::New();
  xShaftActor = vtkActor::New();
  xShaft->SetResolution(40);
  xShaft->SetHeight(shaftLength);
  xShaft->SetRadius(shaftLength / 200.0);
  xShaftMapper->SetInputConnection(xShaft->GetOutputPort());
  xShaftMapper->ScalarVisibilityOff();
  xShaftActor->RotateZ(90);
  xShaftActor->SetPosition(shaftLength / 2.0, 0, 0);
  xShaftActor->SetMapper(xShaftMapper);
  xShaftActor->GetProperty()->SetColor(1, 0, 0);

  vtkConeSource *yCone = vtkConeSource::New();
  vtkPolyDataMapper *yConeMapper = vtkPolyDataMapper::New();
  yConeActor = vtkActor::New();
  yCone->SetResolution(40);
  yCone->SetHeight(shaftLength / 10.0);
  yCone->SetRadius(shaftLength * 0.0375);
  yCone->SetDirection(0, 1, 0);
  yConeMapper->SetInputConnection(yCone->GetOutputPort());
  yConeActor->SetPosition(0, shaftLength, 0);
  yConeMapper->ScalarVisibilityOff();
  yConeActor->SetMapper(yConeMapper);
  yConeActor->GetProperty()->SetColor(0, 1, 0);
  
  vtkCylinderSource *yShaft = vtkCylinderSource::New();
  vtkPolyDataMapper *yShaftMapper = vtkPolyDataMapper::New();
  yShaftActor = vtkActor::New();
  yShaft->SetResolution(40);
  yShaft->SetHeight(shaftLength);
  yShaft->SetRadius(shaftLength / 200.0);
  yShaftMapper->SetInputConnection(yShaft->GetOutputPort());
  yShaftMapper->ScalarVisibilityOff();
  yShaftActor->SetPosition(0, shaftLength / 2.0, 0);
  yShaftActor->SetMapper(yShaftMapper);
  yShaftActor->GetProperty()->SetColor(0, 1, 0);

  vtkConeSource *zCone = vtkConeSource::New();
  vtkPolyDataMapper *zConeMapper = vtkPolyDataMapper::New();
  zConeActor = vtkActor::New();
  zCone->SetResolution(40);
  zCone->SetHeight(shaftLength / 10.0);
  zCone->SetRadius(shaftLength * 0.0375);
  zCone->SetDirection(0, 0, 1);
  zConeMapper->SetInputConnection(zCone->GetOutputPort());
  zConeActor->SetPosition(0, 0, shaftLength);
  zConeMapper->ScalarVisibilityOff();
  zConeActor->SetMapper(zConeMapper);
  zConeActor->GetProperty()->SetColor(0, 0, 1);
  
  vtkCylinderSource *zShaft = vtkCylinderSource::New();
  vtkPolyDataMapper *zShaftMapper = vtkPolyDataMapper::New();
  zShaftActor = vtkActor::New();
  zShaft->SetResolution(40);
  zShaft->SetHeight(shaftLength);
  zShaft->SetRadius(shaftLength / 200.0);
  zShaftMapper->SetInputConnection(zShaft->GetOutputPort());
  zShaftMapper->ScalarVisibilityOff();
  zShaftActor->RotateX(90);
  zShaftActor->SetPosition(0, 0, shaftLength / 2.0);
  zShaftActor->SetMapper(zShaftMapper);
  zShaftActor->GetProperty()->SetColor(0, 0, 1);
  
  vtkCubeSource *origin = vtkCubeSource::New();
  vtkPolyDataMapper *oMapper = vtkPolyDataMapper::New();
  oActor = vtkActor::New();
  origin->SetXLength(shaftLength * 0.025);
  origin->SetYLength(shaftLength * 0.025);
  origin->SetZLength(shaftLength * 0.025);
  oMapper->SetInputConnection(origin->GetOutputPort());
  oMapper->ScalarVisibilityOff();
  oActor->SetMapper(oMapper);
  oActor->GetProperty()->SetColor(1, 1, 1);
  
  char x[] = "+x";
  char y[] = "+y";
  char z[] = "+z";
/*
  renderer->AddActor(xConeActor);
  renderer->AddActor(yConeActor);
  renderer->AddActor(zConeActor);
  renderer->AddActor(xShaftActor);
  renderer->AddActor(yShaftActor);
  renderer->AddActor(zShaftActor);
  renderer->AddActor(oActor);
  AddFollowingText(x, 23, -1, 0, 1, 0, 0, renderer);
  AddFollowingText(y, -1, 23, 0, 0, 1, 0, renderer);
  AddFollowingText(z, 0, -1, 23, 0, 0, 1, renderer);
*/

  vtkFollower *xf = AddFollowingText(x, shaftLength, -shaftLength / 20.0, 0, 1, 0, 0, renderer);
  vtkFollower *yf = AddFollowingText(y, -shaftLength / 20.0, shaftLength, 0, 0, 1, 0, renderer);
  vtkFollower *zf = AddFollowingText(z, 0, -shaftLength / 20.0, shaftLength, 0, 0, 1, renderer);

  xf->SetScale(shaftLength / 30.0);
  yf->SetScale(shaftLength / 30.0);
  zf->SetScale(shaftLength / 30.0);

  vtkAssembly *assembly = vtkAssembly::New();
	assembly->AddPart(xConeActor);
	assembly->AddPart(yConeActor);
	assembly->AddPart(zConeActor);
	assembly->AddPart(xShaftActor);
	assembly->AddPart(yShaftActor);
	assembly->AddPart(zShaftActor);
	assembly->AddPart(oActor);
	assembly->AddPart(xf);
	assembly->AddPart(yf);
	assembly->AddPart(zf);

  renderer->AddActor(assembly);

  return assembly;
}

///WindowInit//////////////////////////////////////////////////////////////////
//
// Set up the window and associated objects like the renderer, etc.
//
////////////////////////////////////////////////////////////////////////////////
void Projector::WindowInit(vtkRenderWindow *renWin, QVTKWidget *qVTKWidget)
{
  renderer = vtkRenderer::New();
  //renderer->SetBackground(0.8, 0.8, 0.8); // like CERR
  RendererCallback *callback = RendererCallback::New();
  renderer->AddObserver(vtkCommand::StartEvent, callback);
  callback->Delete();

  this->renWin = renWin;
  renWin->SetWindowName("cartoon projection");
  renWin->AddRenderer(renderer);
  renWin->SetSize(kRenWinX, kRenWinY);

  renderWindowInteractor = qVTKWidget->GetInteractor();
  renderWindowInteractor->SetRenderWindow(renWin);
}

///InitExtrema//////////////////////////////////////////////////////////////////
//
// Note:  if InitExtrema() is not called before WindowInit(), the value for 
// actor is either uninitialized or overwritten, thus triggering an access  
// violation. ??SAC
//
////////////////////////////////////////////////////////////////////////////////
void Projector::InitExtrema(void)
{
  for (int structure = ekBladder; structure <= kNumStructureTypes; structure++)
  {
    maxVal[structure][0] = maxVal[structure][1] = maxVal[structure][2]
	= kMaxInit;
    minVal[structure][0] = minVal[structure][1] = minVal[structure][2]
	= kMinInit;
  }
  
  avgZ = 0.0;
}

///PrintStructureName///////////////////////////////////////////////////////////
// 
////////////////////////////////////////////////////////////////////////////////
void Projector::PrintStructureName(eStructureType structureNum)
{
  cout << structureType[structureNum] << ". ";
}  

///ComputeAvgZ///////////////////////////////////////////////////////////////
//
// avgZ is used to set the camera's position and focal point, so this method
// is therefore not an optional diagnostic function.
//
////////////////////////////////////////////////////////////////////////////////
void Projector::ComputeAvgZ(void)
{
  int builtStructNum = 0;
  avgZ = 0.0;
     
  //cout << "\nVertex Extrema: " << endl;
  
  for (int structure = (int)ekBladder; structure < (int)kNumStructureTypes;
	  structure++)
  {
    if (maxVal[structure][0] == kMaxInit)
    {
      continue; // Don't print/process numeric data on unbuilt structures
    }
    
    builtStructNum++;
    
/*    PrintStructureName((eStructureType)structure);
    cout << "\n\tmax = " << maxVal[structure][0]
             << ", " << maxVal[structure][1]
             << ", " << maxVal[structure][2] << endl;
    cout << "\tmin = " << minVal[structure][0]
             << ", " << minVal[structure][1]
             << ", " << minVal[structure][2] << endl;
*/           
    double bdBoxCtr[3];
    bdBoxCtr[0] = (minVal[structure][0] + maxVal[structure][0]) / 2.0; 
    bdBoxCtr[1] = (minVal[structure][1] + maxVal[structure][1]) / 2.0; 
    bdBoxCtr[2] = (minVal[structure][2] + maxVal[structure][2]) / 2.0; 
 
/*
    cout << "\tbounding box center = " << bdBoxCtr[0]
         << ", " << bdBoxCtr[1]
         << ", " << bdBoxCtr[2] << endl;
*/         
    avgZ += bdBoxCtr[2];
  }
  
  avgZ /= builtStructNum;
//  cout << endl;
}

///WriteExtremaToFile///////////////////////////////////////////////////////////
//
// Assumes that ComputeAvgZ() has already completed, so that the value for
// avgZ has been set.
//
////////////////////////////////////////////////////////////////////////////////
void Projector::WriteExtremaToFile(ofstream &outf, int patientNum)
{
  outf << "Patient #" << patientNum << "---------------------------------" 
       << endl;
  
  for (int structure = ekBladder; structure < kNumStructureTypes; structure++)
  {
    outf << structureType[structure] << ":";
    
    if (maxVal[structure][0] == kMaxInit)
    {
      outf << "\n\tunbuilt.\n" << endl;
      continue; // Don't print/process numeric data on unbuilt structures
    }
        
    outf << "\n\tmax = " << maxVal[structure][0]
             << ", " << maxVal[structure][1]
             << ", " << maxVal[structure][2] << endl;
    outf << "\tmin = " << minVal[structure][0]
             << ", " << minVal[structure][1]
             << ", " << minVal[structure][2] << endl;
            
    double bdBoxCtr[3];
    bdBoxCtr[0] = (minVal[structure][0] + maxVal[structure][0]) / 2.0; 
    bdBoxCtr[1] = (minVal[structure][1] + maxVal[structure][1]) / 2.0; 
    bdBoxCtr[2] = (minVal[structure][2] + maxVal[structure][2]) / 2.0; 
    
    outf << "\tbounding box center = " << bdBoxCtr[0]
         << ", " << bdBoxCtr[1]
         << ", " << bdBoxCtr[2] << endl;
  }
  
  outf << "avgZ: " << avgZ << "\n" << endl;
}

///ReportCameraPosition/////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////
void Projector::ReportCameraPosition(vtkRenderer *renderer)
{
  double pos[3], fp[3], vUp[3];
  renderer->GetActiveCamera()->GetPosition(pos);
  renderer->GetActiveCamera()->GetFocalPoint(fp);  
  renderer->GetActiveCamera()->GetViewUp(vUp);  
 cout << "\n///Active Camera////////////////////////////////////" << endl;
 cout << "position: (" << pos[0] << ", " << pos[1] << ", " << pos[2] << ")"
      << endl;
 cout << "focal point: (" << fp[0] << ", " << fp[1] << ", " << fp[2] << ")"
      << endl;
 cout << "view up: (" << vUp[0] << ", " << vUp[1] << ", " << vUp[2] << ")"
      << endl;
      
 cout << "////////////////////////////////////////////////////" << endl;
}

///SetCameraPosition////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////
void Projector::SetCameraPosition(vtkRenderer *renderer, 
	double pos[3], double fp[3], double vUp[3])
{
  renderer->GetActiveCamera()->SetPosition(pos);
  renderer->GetActiveCamera()->SetFocalPoint(fp);  
  renderer->GetActiveCamera()->SetViewUp(vUp);  
}

///SetCameraPosition////////////////////////////////////////////////////////////
//
// Setting camera position and orientation to values for gantry angles with
// azimuth defined by argument az.
//
////////////////////////////////////////////////////////////////////////////////
void Projector::SetCameraPosition(double az)
{
	double posY = -150; // 1/28/11 changed from -250
	//double posY = -210; // 04/13/11 so the body is entirely visible

  renderer->GetActiveCamera()->SetPosition(64.5, posY, avgZ);   // campos in Matlab
  renderer->GetActiveCamera()->SetFocalPoint(64, 64, avgZ);     // camtarget "
  renderer->GetActiveCamera()->SetViewUp(0, 0, -1);             // camup     "
  renderer->GetActiveCamera()->Azimuth(-az);                    // [az,el] = view "
}

///UpdateExtrema////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////
void Projector::UpdateExtrema(eStructureType structure, double v[3])
{
  if (v[0] > maxVal[structure][0]) maxVal[structure][0] = v[0]; 
  if (v[1] > maxVal[structure][1]) maxVal[structure][1] = v[1]; 
  if (v[2] > maxVal[structure][2]) maxVal[structure][2] = v[2];
  if (v[0] < minVal[structure][0]) minVal[structure][0] = v[0]; 
  if (v[1] < minVal[structure][1]) minVal[structure][1] = v[1]; 
  if (v[2] < minVal[structure][2])
  {
	  minVal[structure][2] = v[2]; 
	  double minBin = minVal[structure][2];
  }
}

///BuildStructure///////////////////////////////////////////////////////////////
//
// Read in geometric data from the appropriate files -- assumed to have been
// generated by our modified version of CERR -- and generate a 3D surface
// therefrom.
//
////////////////////////////////////////////////////////////////////////////////
bool Projector::BuildStructure(int patientNum, eStructureType st)
{
  char vPath[kMaxChars]; 
  char fPath[kMaxChars];

  QByteArray formatArray = inPathFormat.toAscii();
  char *formatString = formatArray.data();
  sprintf_s(vPath, formatString, patientNum, inFileType[ekVertices], patientNum,
            structureType[st]);
  sprintf_s(fPath, formatString, patientNum, inFileType[ekFaces], patientNum,
            structureType[st]);

// The Carl Zhang/Vorakarn Chanyavanich convention for naming input files:
//     <inFileType>_<patient number>_<structure>.out
// where <inFileType> = [ "faces" | "vertices" ],
//       <patient number> is a 3-digit integer (possibly front-padded with 0's),
// and   <structure>  = [ "bladder" | "LtFem" | "PTV" | "rectum" | "RtFem" ].

  fstream vfs(vPath, ios_base::in); // Vertex File Stream

  if (!vfs.is_open())
  {
    cout << "Failed to open vertices file " << vPath << endl;
    return false;
  }

  fstream ffs(fPath, ios_base::in); // Faces File Stream
   
  if (!ffs.is_open())
  {
    cout << "Failed to open faces file " << fPath << endl;
    return false;
  }
  
  double v[3];
  vtkIdType f[3];
 
  vtkPoints *points = vtkPoints::New();
  int vNum = -1;
  
  while(!vfs.eof())
  {
    vNum++;
    vfs >> v[0] >> v[1] >> v[2];
    vfs.ignore(kMaxChars, '\n');
    //cout << "vertex[" << vNum << "]: " << v[0] << ", " << v[1] << ", " << v[2] << endl;
    points->InsertPoint(vNum, v);
    UpdateExtrema(st, v);   
  }
  
  vfs.close();
  
  vtkCellArray *polys = vtkCellArray::New();
  int fNum = -1;

  while(!ffs.eof())
  {
    fNum++;
   
    ffs >> f[0] >> f[1] >> f[2];
    ffs.ignore(kMaxChars, '\n');
    f[0]--; // Matlab arrays are 1-based vs. 0-based in C/C++. 
    f[1]--;
    f[2]--; 
    //cout << "  face[" << fNum << "]: "<< f[0] << ", " << f[1] << ", " << f[2] << endl;
    polys->InsertNextCell(3, f);
  }
  
  ffs.close();

  /*
  PrintStructureName(st);
  cout << "vNum: " << vNum << "; fNum: " << fNum
       << "; color: " << structureColor[st][0] << ", "
       << structureColor[st][1] << ", "
       << structureColor[st][2] << endl;
 */

  if (structure) structure->Delete(); 
  structure = vtkPolyData::New();
  structure->SetPoints(points);
  points->Delete();
  structure->SetPolys(polys);
  polys->Delete();

#if STRAIGHTPIPE
  cout << "Straight pipe." << endl;

  if (mapper) mapper->Delete();
  mapper = vtkPolyDataMapper::New();
  mapper->SetInput(structure);

#else
  //cout << "Decimated and smoothed." << endl;
  if (deci) deci->Delete(); 
  deci = vtkDecimatePro::New();
  deci->SetInput(structure);
  deci->SetTargetReduction(0.5);
  deci->PreserveTopologyOn();

  if (smoother) smoother->Delete();
  smoother = vtkSmoothPolyDataFilter::New();
  smoother->SetInputConnection(deci->GetOutputPort());
  smoother->SetNumberOfIterations(100);

  if (normals) normals->Delete();
  normals = vtkPolyDataNormals::New();
  normals->SetInputConnection(smoother->GetOutputPort());
  normals->NonManifoldTraversalOff();
  //normals->FlipNormalsOn();
  //normals->FlipNormalsOff();
  normals->AutoOrientNormalsOn();
  normals->ConsistencyOn();
  //normals->ComputeCellNormalsOn();

  if (mapper) mapper->Delete();
  mapper = vtkPolyDataMapper::New();
  mapper->SetInputConnection(normals->GetOutputPort());
#endif

  if (actor) actor->Delete(); 
  actor = vtkActor::New();  
  actor->SetMapper(mapper);
  actor->GetProperty()->SetColor(structureColor[st][0], structureColor[st][1],
	  structureColor[st][2]);
  actor->GetProperty()->SetInterpolationToPhong();

  //actor->GetProperty()->SetOpacity(st == ekBody ? 0.3 : 1.0);

  if (transparency != 0.0)
  {
    //normals->FlipNormalsOn();
	//normals->FlipNormalsOff();
	normals->ComputeCellNormalsOn();
    actor->GetProperty()->SetOpacity(1.0 - (transparency / 100.0));
  }

/* 
  if (st == ekBody)
  {
	actor->GetProperty()->SetSpecular(2);
	actor->GetProperty()->SetSpecularPower(3);
	actor->GetProperty()->SetColor(
		structureColor[st][0],
		structureColor[st][1],
		structureColor[st][2]);
	//actor->GetProperty()->SetSpecularColor(1, 1, 1);
	//actor->GetProperty()->SetSpecularColor(
		structureColor[st][0], 
		structureColor[st][1],
		structureColor[st][2]);
	actor->GetProperty()->SetSpecularColor(.5, .4, .4);
  }
  else
  {
*/
	if (flatShaded)
	{
	  actor->GetProperty()->SetSpecular(0);
	  actor->GetProperty()->SetDiffuse(0);
	  actor->GetProperty()->SetAmbient(1);
	  actor->GetProperty()->SetAmbientColor(
		  structureColor[st][0],
		  structureColor[st][1],
		  structureColor[st][2]);
	  actor->GetProperty()->SetColor(
		  structureColor[st][0],
		  structureColor[st][1],
		  structureColor[st][2]);
	}
	else
	{
	  actor->GetProperty()->SetSpecular(4);
	  actor->GetProperty()->SetSpecularPower(30);
	  actor->GetProperty()->SetColor(
		  structureColor[st][0], 
		  structureColor[st][1],
		  structureColor[st][2]);
	  actor->GetProperty()->SetSpecularColor(1, 1, 1);
	}
/*  } */

  renderer->AddActor(actor);
  
  return true;
}

///BuildStructuresForPatient////////////////////////////////////////////////////
//
// Build all the structures for patientNum.  If none were built return false, 
// else return true.
//
////////////////////////////////////////////////////////////////////////////////
bool Projector::BuildStructuresForPatient(int patientNum)
{
  renderer->RemoveAllViewProps();

  bool wasAtLeastOneStructureBuilt = false;
  
  for (int s = ekBladder; s < kNumStructureTypes; s++)
  {

	if (noFemoralHeads)
	{
	  if ((s == ekLtFem) || (s == ekRtFem)) continue;
	}

    if (BuildStructure(patientNum, (eStructureType)s))
	{
		wasAtLeastOneStructureBuilt = true;
	}
  }

  return wasAtLeastOneStructureBuilt;
}

///InitAxes/////////////////////////////////////////////////////////////////////
//
// Set up the standard VTK axes.
//
////////////////////////////////////////////////////////////////////////////////
void Projector::InitAxes(void)
{
  vtkAxes *axes = vtkAxes::New();
  axes->SetOrigin(0, 0, 0);
  axes->SetScaleFactor(40);
  vtkPolyDataMapper *axesMapper = vtkPolyDataMapper::New();
  axesMapper->SetInputConnection(axes->GetOutputPort());
  vtkActor *axesActor = vtkActor::New();
  axesActor->GetProperty()->SetAmbient(0.5);
  axesActor->SetMapper(axesMapper);
  renderer->AddActor(axesActor);
}

///TextInit/////////////////////////////////////////////////////////////////////
//
// Set up text in the lower (with a default placeholder string) in the lower
// left hand corner of the window.
//
////////////////////////////////////////////////////////////////////////////////
void Projector::TextInit(void)
{
  textActor = vtkTextActor::New();
  textActor->SetHeight(0.34);
  textActor->SetDisplayPosition(10, 3);

  textActor->SetInput("Structure Projections");

  renderer->AddActor(textActor);
}

////SetProjection///////////////////////////////////////////////////////////////
//
// Set the camera angle and add the corresponding text.
//
////////////////////////////////////////////////////////////////////////////////
void Projector::SetProjection(int patientNum, int angle)
{
  char txt[kMaxChars];  
  SetCameraPosition(angle); 
  sprintf_s(txt, "patient #%03d: gantry angle %d degrees", patientNum, angle);
  renderer->AddActor(textActor); // Need to do this every time to see text
  textActor->SetInput(txt);    
  renWin->Render();
}
