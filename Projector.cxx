//////////////////////////////////////////////////////////////////////////////
//
// Projector.h:  Object to read files generated by modified CERR (Matlab)
// code, (in visualStruct3D.m), place the data thereby acquired into a
// vtkPolyData object, color according to the agreed-upon convention, and
// display images.
//
//////////////////////////////////////////////////////////////////////////////

#include "windows.h" 
#include <float.h>

#include <QtGui>
#include "qvtkwidget.h"

#include "vtkPolyDataMapper.h"
#include "vtkActor.h"
#include "vtkProperty.h"
#include "vtkCamera.h"
#include "vtkRenderer.h"
#include "vtkRenderWindowInteractor.h"
#include "vtkRenderWindow.h"
#include "vtkVectorText.h"
#include "vtkConeSource.h"
#include "vtkCubeSource.h"
#include "vtkCylinderSource.h"
#include "vtkFollower.h"
#include "vtkTextActor.h"
#include "vtkTextProperty.h"
#include "vtkCommand.h"
#include "vtkWindowToImageFilter.h"
#include "vtkPNGWriter.h"
#include "vtkCellArray.h"
#include "vtkDecimatePro.h"
#include "vtkPolyDataNormals.h"
#include "vtkSmoothPolyDataFilter.h"
#include "vtkAxes.h"
#include "vtkWindowToImageFilter.h"
#include "vtkAssembly.h"

#include "Projector.h"

using namespace std;

// Window size:
static const int kRenWinX = 460;
static const int kRenWinY = 460;

// const member initializations:
const int Projector::kNumInFileTypes = ekVertices + 1;

// Globals:
static const char inFileType[Projector::kNumInFileTypes][kMaxFileTypeChars]
  = { "faces", "vertices" };

static const char structureType[Projector::kNumStructureTypes][kMaxFileTypeChars]
  = { "bladder", "LtFem", "PTV", "rectum", "RtFem" /*, "body" */ };


// 2011/05/02: values from current CompareDialog:
static const double structureColor[Projector::kNumStructureTypes][3] =
{
  1.0, 0.84, 0.0,       // bladder "golden yellow"
  0.5, 0.5, 0.6,        // left femoral head blue-gray
  0.9, 0.0, 0.0,        // PTV red     
  0.545, 0.271, 0.075,  // rectum "saddle brown"
  0.75, 0.75, 0.75      // right femoral head lite gray
// 0.961, 0.8, 0.69     // flesh F5CCB0 = 245, 204, 176 = 0.961, 0.8, 0.69
};

// The Carl Zhang/Vorakarn Chanyavanich convention for naming structure 
// geometry input files:
//
//     <inFileType>_<patient number>_<structure>.out
// where <inFileType> = [ "faces" | "vertices" ],
//       <patient number> is a 3-digit integer (possibly front-padded with 0's),
// and   <structure>  = [ "bladder" | "LtFem" | "PTV" | "rectum" | "RtFem" ].
//


///ctor/////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////
Projector::Projector()
  : renderWindowInteractor(NULL),
    renWin(NULL), 
    textActor(NULL),
    renderer(NULL),
    isPatientChanged(true),
    flatShaded(true),
    avgX(0.0),
    minX(kMinInit),
    maxX(kMaxInit),
    avgY(0.0),
    minY(kMinInit),
    maxY(kMaxInit),
    avgZ(0.0),
    minZ(kMinInit),
    maxZ(kMaxInit),
    slicePlane(NULL)
{
  for (int i = ekBladder; i < kNumStructureTypes; i++)
  {
    drawStructure[i] = true;
    legendTextActor[i] = NULL;
  }
}

///ctor/////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////
Projector::Projector(QString dataDir)
  : renderWindowInteractor(NULL),
    renWin(NULL), 
    textActor(NULL),
    renderer(NULL),
    isPatientChanged(true),
    flatShaded(true),
    avgX(0.0),
    minX(kMinInit),
    maxX(kMaxInit),
    avgY(0.0),
    minY(kMinInit),
    maxY(kMaxInit),
    avgZ(0.0),
    minZ(kMinInit),
    maxZ(kMaxInit),
    slicePlane(NULL)
{
  inPathFormat = dataDir + "/structures/%03d/%s_%03d_%s.out";

  for (int i = ekBladder; i < kNumStructureTypes; i++)
  {
    drawStructure[i] = true;

    points[i] = NULL;
    polys[i] = NULL;
    structure[i] = NULL;
    deci[i] = NULL;
    smoother[i] = NULL;
    normals[i] = NULL;
    mapper[i] = NULL;
    actor[i] = NULL;

    legendTextActor[i] = NULL;
  }
}

///dtor/////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////
Projector::~Projector()
{
  if (textActor) textActor->Delete();
  if (renderer) renderer->Delete();
  if (slicePlane) slicePlane->Delete();

  for (int i = ekBladder; i < kNumStructureTypes; i++)
  {
    if (legendTextActor[i]) legendTextActor[i]->Delete();
    if (points[i]) points[i]->Delete();
    if (polys[i]) polys[i]->Delete();
    if (structure[i]) structure[i]->Delete();
    if (deci[i]) deci[i]->Delete();
    if (smoother[i]) smoother[i]->Delete();
    if (normals[i]) normals[i]->Delete();
    if (mapper[i]) mapper[i]->Delete();
    if (actor[i]) actor[i]->Delete();
  }
};

////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////
void Projector::setTransparency(int transp)
{
  transparency = transp;
}

///WindowInit//////////////////////////////////////////////////////////////////
//
// Set up the window and associated objects like the renderer, etc.
//
////////////////////////////////////////////////////////////////////////////////
void Projector::WindowInit(vtkRenderWindow *renWin, QVTKWidget *qVTKWidget)
{
  renderer = vtkRenderer::New();
  //renderer->SetBackground(0.8, 0.8, 0.8); // like CERR

  this->renWin = renWin;
  renWin->SetWindowName("cartoon projection");
  renWin->AddRenderer(renderer);
  renWin->SetSize(kRenWinX, kRenWinY);

  vtkWidget = qVTKWidget;

  renderWindowInteractor = qVTKWidget->GetInteractor();
  renderWindowInteractor->SetRenderWindow(renWin);
}

///InitExtrema//////////////////////////////////////////////////////////////////
//
// Note:  if InitExtrema() is not called before WindowInit(), the value for 
// actor is either uninitialized or overwritten, thus triggering an access  
// violation. ??SAC
//
////////////////////////////////////////////////////////////////////////////////
void Projector::InitExtrema(void)
{  
  minX = kMinInit;
  maxX = kMaxInit;
  minY = kMinInit;
  maxY = kMaxInit;
  minZ = kMinInit;
  maxZ = kMaxInit;
}

///PrintStructureName///////////////////////////////////////////////////////////
// 
////////////////////////////////////////////////////////////////////////////////
void Projector::PrintStructureName(eStructureType structureNum)
{
  cout << structureType[structureNum] << ". ";
}  

///ComputeAverages///////////////////////////////////////////////////////////////
//
// avgZ is used to set the camera's position and focal point, so this method
// is therefore not an optional diagnostic function.
//
////////////////////////////////////////////////////////////////////////////////
void Projector::ComputeAverages(void)
{
  avgX = (minX + maxX) / 2.0;
  avgY = (minY + maxY) / 2.0;
  avgZ = (minZ + maxZ) / 2.0;
}

///ReportCameraPosition/////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////
void Projector::ReportCameraPosition(vtkRenderer *renderer)
{
  double pos[3], fp[3], vUp[3];
  renderer->GetActiveCamera()->GetPosition(pos);
  renderer->GetActiveCamera()->GetFocalPoint(fp);  
  renderer->GetActiveCamera()->GetViewUp(vUp);  
 cout << "\n///Active Camera////////////////////////////////////" << endl;
 cout << "position: (" << pos[0] << ", " << pos[1] << ", " << pos[2] << ")"
      << endl;
 cout << "focal point: (" << fp[0] << ", " << fp[1] << ", " << fp[2] << ")"
      << endl;
 cout << "view up: (" << vUp[0] << ", " << vUp[1] << ", " << vUp[2] << ")"
      << endl;
      
 cout << "////////////////////////////////////////////////////" << endl;
}

///SetCameraPosition////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////
void Projector::SetCameraPosition(vtkRenderer *renderer, 
  double pos[3], double fp[3], double vUp[3])
{
  renderer->GetActiveCamera()->SetPosition(pos);
  renderer->GetActiveCamera()->SetFocalPoint(fp);  
  renderer->GetActiveCamera()->SetViewUp(vUp);  
}

///SetCameraPosition////////////////////////////////////////////////////////////
//
// Setting camera position and orientation to values for gantry angles with
// azimuth defined by argument az.
//
////////////////////////////////////////////////////////////////////////////////
void Projector::SetCameraPosition(double az)
{
  double posY = -150; // 1/28/11 changed from -250
  //double posY = -210; // 04/13/11 so the body is entirely visible

  renderer->GetActiveCamera()->SetPosition(64.5, posY, avgZ);   // campos in Matlab
  renderer->GetActiveCamera()->SetFocalPoint(64, 64, avgZ);     // camtarget "
  renderer->GetActiveCamera()->SetViewUp(0, 0, -1);             // camup     "
  renderer->GetActiveCamera()->Azimuth(-az);                    // [az,el] = view "
}

///UpdateExtrema////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////
void Projector::UpdateExtrema(eStructureType structure, double v[3])
{
  if (v[0] < minX) minX = v[0];
  if (v[0] > maxX) maxX = v[0];
  if (v[1] < minY) minY = v[1];
  if (v[1] > maxY) maxY = v[1];
  if (v[2] < minZ) minZ = v[2];
  if (v[2] > maxZ) maxZ = v[2];
}

///BuildStructure///////////////////////////////////////////////////////////////
//
// Read in geometric data from the appropriate files -- assumed to have been
// generated by our modified version of CERR -- and generate a 3D surface
// therefrom.
//
////////////////////////////////////////////////////////////////////////////////
bool Projector::BuildStructure(int patientNum, eStructureType st)
{
  char vPath[kMaxChars]; 
  char fPath[kMaxChars];

  QByteArray formatArray = inPathFormat.toAscii();
  char *formatString = formatArray.data();
  sprintf_s(vPath, formatString, patientNum, inFileType[ekVertices], patientNum,
            structureType[st]);
  sprintf_s(fPath, formatString, patientNum, inFileType[ekFaces], patientNum,
            structureType[st]);

// The Carl Zhang/Vorakarn Chanyavanich convention for naming input files:
//     <inFileType>_<patient number>_<structure>.out
// where <inFileType> = [ "faces" | "vertices" ],
//       <patient number> is a 3-digit integer (possibly front-padded with 0's),
// and   <structure>  = [ "bladder" | "LtFem" | "PTV" | "rectum" | "RtFem" ].

  fstream vfs(vPath, ios_base::in); // Vertex File Stream

  if (!vfs.is_open())
  {
    cout << "Failed to open vertices file " << vPath << endl;
    return false;
  }

  fstream ffs(fPath, ios_base::in); // Faces File Stream
   
  if (!ffs.is_open())
  {
    cout << "Failed to open faces file " << fPath << endl;
    return false;
  }
  
  double v[3];
  vtkIdType f[3];
 
  points[st] = vtkPoints::New();
  int vNum = -1;
  
  while(!vfs.eof())
  {
    vNum++;
    vfs >> v[0] >> v[1] >> v[2];
    vfs.ignore(kMaxChars, '\n');
    //cout << "vertex[" << vNum << "]: " << v[0] << ", " << v[1] << ", " << v[2] << endl;
    points[st]->InsertPoint(vNum, v);
    if (isPatientChanged) UpdateExtrema(st, v);   
  }
  
  vfs.close();
  
  polys[st] = vtkCellArray::New();
  int fNum = -1;

  while(!ffs.eof())
  {
    fNum++;
   
    ffs >> f[0] >> f[1] >> f[2];
    ffs.ignore(kMaxChars, '\n');
    f[0]--; // Matlab arrays are 1-based vs. 0-based in C/C++. 
    f[1]--;
    f[2]--; 
    polys[st]->InsertNextCell(3, f);
  }
  
  ffs.close();

  structure[st] = vtkPolyData::New();
  structure[st]->SetPoints(points[st]);
  structure[st]->SetPolys(polys[st]);

#if STRAIGHTPIPE
  cout << "Straight pipe." << endl;

  if (mapper) mapper->Delete();
  mapper = vtkPolyDataMapper::New();
  mapper->SetInput(structure);

#else
  //cout << "Decimated and smoothed." << endl;
  deci[st] = vtkDecimatePro::New();
  deci[st]->SetInput(structure[st]);
  deci[st]->SetTargetReduction(0.5);
  deci[st]->PreserveTopologyOn();

  smoother[st] = vtkSmoothPolyDataFilter::New();
  smoother[st]->SetInputConnection(deci[st]->GetOutputPort());
  smoother[st]->SetNumberOfIterations(100);

  normals[st] = vtkPolyDataNormals::New();
  normals[st]->SetInputConnection(smoother[st]->GetOutputPort());
  normals[st]->NonManifoldTraversalOff();
  //normals->FlipNormalsOn();
  //normals->FlipNormalsOff();
  normals[st]->AutoOrientNormalsOn();
  normals[st]->ConsistencyOn();
  //normals->ComputeCellNormalsOn();

  mapper[st] = vtkPolyDataMapper::New();
  mapper[st]->SetInputConnection(normals[st]->GetOutputPort());
#endif

  actor[st] = vtkActor::New();  
  actor[st]->SetMapper(mapper[st]);
  actor[st]->GetProperty()->SetColor(structureColor[st][0], structureColor[st][1],
    structureColor[st][2]);
  actor[st]->GetProperty()->SetInterpolationToPhong();

  //actor->GetProperty()->SetOpacity(st == ekBody ? 0.3 : 1.0);

  if (transparency != 0.0)
  {
    //normals->FlipNormalsOn();
    //normals->FlipNormalsOff();
    normals[st]->ComputeCellNormalsOn();
    actor[st]->GetProperty()->SetOpacity(1.0 - (transparency / 100.0));
  }

/* 
  if (st == ekBody)
  {
  actor->GetProperty()->SetSpecular(2);
  actor->GetProperty()->SetSpecularPower(3);
  actor->GetProperty()->SetColor(
    structureColor[st][0],
    structureColor[st][1],
    structureColor[st][2]);
  //actor->GetProperty()->SetSpecularColor(1, 1, 1);
  //actor->GetProperty()->SetSpecularColor(
    structureColor[st][0], 
    structureColor[st][1],
    structureColor[st][2]);
  actor->GetProperty()->SetSpecularColor(.5, .4, .4);
  }
  else
  {
*/
  if (flatShaded)
  {
    actor[st]->GetProperty()->SetSpecular(0);
    actor[st]->GetProperty()->SetDiffuse(0);
    actor[st]->GetProperty()->SetAmbient(1);
    actor[st]->GetProperty()->SetAmbientColor(
      structureColor[st][0],
      structureColor[st][1],
      structureColor[st][2]);
    actor[st]->GetProperty()->SetColor(
      structureColor[st][0],
      structureColor[st][1],
      structureColor[st][2]);
  }
  else
  {
    actor[st]->GetProperty()->SetSpecular(4);
    actor[st]->GetProperty()->SetSpecularPower(30);
    actor[st]->GetProperty()->SetColor(
      structureColor[st][0], 
      structureColor[st][1],
      structureColor[st][2]);
    actor[st]->GetProperty()->SetSpecularColor(1, 1, 1);
  }
/*  } */

  renderer->AddActor(actor[st]);
  
  return true;
}

double MAX(double a, double b, double c)
{
  return (a > b) ? ((a > c) ? a : c) : ((b > c) ? b : c);
}

double MIN(double a, double b, double c)
{
  return (a < b) ? ((a < c) ? a : c) : ((b < c) ? b : c);
}

///BuildStructuresForPatient////////////////////////////////////////////////////
//
// Build all the requested structures for patientNum.  If none were built return
// false, else return true.
//
// If it's a first or different patient, initialize and recompute extrema and 
// averages.  If it's the same patient with different structures, don't
// recompute, to avoid the stuctures moving around in the render window.
//
////////////////////////////////////////////////////////////////////////////////
bool Projector::BuildStructuresForPatient(int patientNum, bool isDifferentPatient /* = false */)
{
  isPatientChanged = isDifferentPatient;

  renderer->RemoveAllViewProps();

  bool wasAtLeastOneStructureBuilt = false;
  
  for (int s = ekBladder; s < kNumStructureTypes; s++)
  {
    if (!drawStructure[s]) continue;

    if (BuildStructure(patientNum, (eStructureType)s))
    {
        wasAtLeastOneStructureBuilt = true;
    }
  }

  InitSlicePlane();
  renderer->GetActiveCamera()->SetClippingRange(1.0, MAX(maxX, maxY, maxZ) * 3.0);
/*
  if (isPatientChanged)
  {
    cout << "Projector::BuildStructuresForPatient(...) patient #"
     << patientNum << " extrema: " 
     << minX << ", " << maxX << "; "
     << minY << ", " << maxY << "; "
     << minZ << ", " << maxZ << endl;
  
    double *clip = renderer->GetActiveCamera()->GetClippingRange();
    cout << "min: " << MIN(minX, minY, minZ) << endl;
    cout << clip[0] << ", " << clip[1] << endl;
  }
*/
  isPatientChanged = false;

  return wasAtLeastOneStructureBuilt;
}

///InitAxes/////////////////////////////////////////////////////////////////////
//
// Set up the standard VTK axes.
//
////////////////////////////////////////////////////////////////////////////////
void Projector::InitAxes(void)
{
  vtkAxes *axes = vtkAxes::New();
  axes->SetOrigin(0, 0, 0);
  axes->SetScaleFactor(40);
  vtkPolyDataMapper *axesMapper = vtkPolyDataMapper::New();
  axesMapper->SetInputConnection(axes->GetOutputPort());
  vtkActor *axesActor = vtkActor::New();
  axesActor->GetProperty()->SetAmbient(0.5);
  axesActor->SetMapper(axesMapper);
  renderer->AddActor(axesActor);
}

///TextInit/////////////////////////////////////////////////////////////////////
//
// Set up text in the lower (with a default placeholder string) in the lower
// left hand corner of the window.
//
////////////////////////////////////////////////////////////////////////////////
void Projector::TextInit(void)
{
  textActor = vtkTextActor::New();
  textActor->SetHeight(0.34);
  textActor->SetDisplayPosition(10, 3);

  textActor->SetInput("Structure Projections");

  renderer->AddActor(textActor);
}

///InitLegend///////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////
void Projector::InitLegend()
{
  if (legendTextActor[0]) return;

  // HACK: copied from CompareDialog.cpp (to get the ordering right):
  static const char *shortStructureName[kNumStructureTypes] =
  {
    "PTV",    // Planning Target Volume
    "rectum",
    "bladder",
    "left fem",
    "right fem"
  };

  // SAME HACK: rgb values, 0.0-1.0 range:
  static const double structureColor[kNumStructureTypes][3] =
  {
    0.9, 0.0, 0.0,        // PTV red     
    0.545, 0.271, 0.075,  // rectum "saddle brown"
    1.0, 0.84, 0.0,       // bladder "golden yellow"
    0.5, 0.5, 0.6,        // left femoral head blue-gray
    0.75, 0.75, 0.75      // right femoral head lite gray
  };

  const int startY = kRenWinY - 20;
  const int yDecrement = 15;
  const int startX = kRenWinX - 60;

  for (int i = 0; i < kNumStructureTypes; i++)
  {
    legendTextActor[i] = vtkTextActor::New();
    legendTextActor[i]->SetHeight(0.25);
    legendTextActor[i]->SetDisplayPosition(startX, startY - i * yDecrement);
    legendTextActor[i]->GetTextProperty()->SetColor(1, 1, 0);
    legendTextActor[i]->GetTextProperty()->BoldOn();
    legendTextActor[i]->SetInput(shortStructureName[i]);
    legendTextActor[i]->GetTextProperty()->SetColor(
      structureColor[i][0], structureColor[i][1], structureColor[i][2]);
    renderer->AddActor(legendTextActor[i]);
  }
}

////SetProjection///////////////////////////////////////////////////////////////
//
// Set the camera angle and add the corresponding text.
//
////////////////////////////////////////////////////////////////////////////////
void Projector::SetProjection(int patientNum, int angle)
{
  char txt[kMaxChars];  
  SetCameraPosition(angle); 
  sprintf_s(txt, "Duke patient #%03d: gantry angle %d degrees", patientNum,
    angle);
  renderer->RemoveActor(textActor);
  renderer->AddActor(textActor); // Need to do this every time to see text
  textActor->SetInput(txt);

  for (int i = 0; i < kNumStructureTypes; i++) // Why? Dunno, but it works
  {
    if (legendTextActor[i]) 
    {
      renderer->RemoveActor(legendTextActor[i]);
      renderer->AddActor(legendTextActor[i]);
    }
  }

  vtkWidget->GetRenderWindow()->Render();
  //ReportCameraPosition(renderer);
}

////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////
void Projector::InitSlicePlane()
{
  if (slicePlane)
  {
    slicePlane->Delete();
    sliceMapper->Delete();
    sliceActor->Delete();
  }

  slicePlane = vtkCubeSource::New();
  sliceMapper = vtkPolyDataMapper::New();
  sliceActor = vtkActor::New();
 

  sliceMapper->SetInputConnection(slicePlane->GetOutputPort());
  sliceMapper->ScalarVisibilityOff();
  sliceActor->SetMapper(sliceMapper);
  sliceActor->GetProperty()->SetOpacity(0.2);

#if USE_PROJECTOR_SLICE_PLANE
  renderer->AddActor(sliceActor);  
#endif
}

////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////
void Projector::PositionSlicePlane(int orientation, int slice, double *spacing)
{
  slicePlane->SetCenter(avgX, avgY, avgZ);

  slicePlane->SetXLength(maxX - minX);
  slicePlane->SetYLength(maxY - minY);
  slicePlane->SetZLength(maxZ - minZ);

  const double thinDimension = 1.0;

  switch(orientation)
  {
  case 0: // Sagittal
    slicePlane->SetXLength(spacing[0]);
    slicePlane->SetCenter(slice * spacing[0], avgY, avgZ);
    break;
  case 1: // Coronal
    slicePlane->SetYLength(spacing[1]);
    slicePlane->SetCenter(avgX, slice * spacing[1], avgZ);
    break;
  case 2: // Axial
    slicePlane->SetZLength(spacing[2]);
    slicePlane->SetCenter(avgX, avgY, slice * spacing[2]);
    break;
  default:
    cout << "Projector::PositionSlicePlane(...): Invalid orientation: " << endl;    
    break;
  }

  renWin->Render();
}

////////////////////////////////////////////////////////////////////////////////
//
// TEMP hack 
//
////////////////////////////////////////////////////////////////////////////////
void Projector::PositionSlicePlane(int orientation, int slice, int numSlices)
{
  slicePlane->SetCenter(avgX, avgY, avgZ);

  slicePlane->SetXLength(maxX - minX);
  slicePlane->SetYLength(maxY - minY);
  slicePlane->SetZLength(maxZ - minZ);

  const double thinDimension = 1.0;

  double rangeXMin = avgX - 2 * (avgX - minX);
  double rangeYMin = avgY - 2 * (avgY - minY);
  double rangeZMin = avgZ - 2 * (avgZ - minZ);
  double rangeXMax = avgX + 2 * (maxX - avgX);
  double rangeYMax = avgY + 2 * (maxY - avgY);
  double rangeZMax = avgZ + 2 * (maxZ - avgZ);

  double xSliceSize = (rangeXMax - rangeXMin) / numSlices;
  double ySliceSize = (rangeYMax - rangeYMin) / numSlices;
  double zSliceSize = (rangeZMax - rangeZMin) / numSlices;

  switch(orientation)
  {
  case 0: // Sagittal
    slicePlane->SetXLength(thinDimension);
    //slicePlane->SetXLength(spacing[0]);
    //slicePlane->SetCenter(slice * spacing[0], avgY, avgZ);
    //slicePlane->SetCenter(rangeXMin + (xSliceSize * slice), avgY, avgZ);
    slicePlane->SetCenter(rangeXMax - (xSliceSize * slice), avgY, avgZ);
    break;
  case 1: // Coronal
    slicePlane->SetYLength(thinDimension);
    //slicePlane->SetYLength(spacing[1]);
    slicePlane->SetCenter(avgX, rangeYMax - (ySliceSize * slice), avgZ);
    break;
  case 2: // Axial
    slicePlane->SetZLength(thinDimension);
    //slicePlane->SetZLength(spacing[2]);
    slicePlane->SetCenter(avgX, avgY, rangeZMin + (zSliceSize * slice));
    break;
  default:
    cout << "Projector::PositionSlicePlane(...): Invalid orientation: "
       << endl;    
    break;
  }

  renWin->Render();
}
